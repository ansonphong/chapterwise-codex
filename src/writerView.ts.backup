/**
 * Writer View - Scrivener-like distraction-free prose editing
 * Webview-based editor for Codex node content
 */

import * as vscode from 'vscode';
import * as fs from 'fs';
import * as YAML from 'yaml';
import { 
  CodexNode, 
  CodexDocument, 
  CodexAttribute,
  CodexContentSection,
  parseCodex,
  parseMarkdownAsCodex,
  setNodeProse, 
  setMarkdownNodeProse,
  setMarkdownFrontmatterField,
  setNodeName,
  getNodeProse,
  getNodeAttributes,
  setNodeAttributes,
  getNodeContentSections,
  setNodeContentSections,
  generateUuid,
  isMarkdownFile
} from './codexModel';
import { CodexTreeItem, CodexFieldTreeItem } from './treeProvider';

/**
 * Interface for Writer View panel statistics
 */
interface WriterPanelStats {
  wordCount: number;
  charCount: number;
  nodeName: string;
  field?: string;
}

/**
 * Manages Writer View webview panels
 */
export class WriterViewManager {
  private panels: Map<string, vscode.WebviewPanel> = new Map();
  private lastSelectedField: string = 'body';  // Remember field across node switches
  private wordCountStatusBarItem: vscode.StatusBarItem;
  private panelStats: Map<string, WriterPanelStats> = new Map();
  
  constructor(private readonly context: vscode.ExtensionContext) {
    // Create word count status bar item
    this.wordCountStatusBarItem = vscode.window.createStatusBarItem(
      vscode.StatusBarAlignment.Right,
      200  // Priority (position in status bar)
    );
    context.subscriptions.push(this.wordCountStatusBarItem);
  }
  
  /**
   * Calculate statistics from text
   */
  private calculateStats(text: string, nodeName: string, field?: string): WriterPanelStats {
    const wordCount = text.trim() ? text.trim().split(/\s+/).length : 0;
    const charCount = text.length;
    
    return {
      wordCount,
      charCount,
      nodeName,
      field
    };
  }
  
  /**
   * Update status bar with word count
   */
  private updateStatusBar(stats: WriterPanelStats): void {
    // Primary display: word count
    this.wordCountStatusBarItem.text = `$(pencil) ${stats.wordCount} words`;
    
    // Rich tooltip with all stats
    const tooltipLines = [
      `${stats.wordCount} words in "${stats.nodeName}"`,
      `${stats.charCount} characters`
    ];
    
    if (stats.field) {
      tooltipLines.push(`Field: ${stats.field}`);
    }
    
    this.wordCountStatusBarItem.tooltip = tooltipLines.join('\n');
    this.wordCountStatusBarItem.show();
  }
  
  /**
   * Hide status bar item
   */
  private hideStatusBar(): void {
    this.wordCountStatusBarItem.hide();
  }
  
  /**
   * Update status bar to show the currently active Writer View panel
   */
  private updateStatusBarForActivePanel(): void {
    // Find the panel that is both visible AND active
    for (const [key, panel] of this.panels.entries()) {
      if (panel.active && panel.visible) {
        const stats = this.panelStats.get(key);
        if (stats) {
          this.updateStatusBar(stats);
          return;
        }
      }
    }
    
    // No active Writer View found - hide status bar
    this.hideStatusBar();
  }
  
  /**
   * Store stats for a panel and update status bar if it's active
   */
  private updateStatsForPanel(
    panelKey: string, 
    panel: vscode.WebviewPanel,
    stats: WriterPanelStats
  ): void {
    // Store stats for this panel
    this.panelStats.set(panelKey, stats);
    
    // Only update status bar if THIS panel is the active one
    if (panel.active && panel.visible) {
      this.updateStatusBar(stats);
    }
  }
  
  /**
   * Get the theme setting from configuration
   */
  private getThemeSetting(): 'light' | 'dark' | 'system' | 'theme' {
    const config = vscode.workspace.getConfiguration('chapterwiseCodex.writerView');
    return config.get<'light' | 'dark' | 'system' | 'theme'>('theme', 'theme');
  }
  
  /**
   * Get the current VS Code theme kind (light or dark)
   */
  private getVSCodeThemeKind(): 'light' | 'dark' {
    const colorTheme = vscode.window.activeColorTheme;
    return colorTheme.kind === vscode.ColorThemeKind.Light ? 'light' : 'dark';
  }
  
  /**
   * Open or focus a Writer View for a node
   */
  async openWriterView(treeItem: CodexTreeItem): Promise<void> {
    const node = treeItem.codexNode;
    const documentUri = treeItem.documentUri;
    
    // Create a unique key for this panel
    const panelKey = `${documentUri.toString()}#${node.id || node.path.join('/')}`;
    
    // Check if panel already exists - just focus it
    let existingPanel = this.panels.get(panelKey);
    if (existingPanel) {
      existingPanel.reveal(vscode.ViewColumn.Active);
      return;
    }
    
    // Read file directly - DON'T open in VS Code text editor
    const fileName = documentUri.fsPath;
    const text = fs.readFileSync(fileName, 'utf-8');
    
    // Use appropriate parser based on file type
    const codexDoc = isMarkdownFile(fileName) 
      ? parseMarkdownAsCodex(text, fileName)
      : parseCodex(text);
      
    if (!codexDoc) {
      const fileType = isMarkdownFile(fileName) ? 'Markdown' : 'Codex';
      vscode.window.showErrorMessage(`Unable to parse ${fileType} document`);
      return;
    }
    
    // Determine initial field based on entity structure (unless user has a remembered preference)
    let initialField: string;
    if (this.lastSelectedField && this.lastSelectedField.trim()) {
      // Use remembered field if available
      initialField = this.lastSelectedField;
    } else {
      // Smart default: overview for multi-field entities, single field otherwise
      const proseFieldCount = node.availableFields.filter(f => !f.startsWith('__')).length;
      const hasChildren = node.children && node.children.length > 0;
      const hasContentSections = node.hasContentSections;
      const hasAttributes = node.hasAttributes;
      
      // Count total fields
      const fieldCount = proseFieldCount + (hasContentSections ? 1 : 0) + (hasAttributes ? 1 : 0) + (hasChildren ? 1 : 0);
      
      // Default to overview if multiple fields, otherwise show the single field
      if (fieldCount > 1) {
        initialField = '__overview__';
      } else if (node.availableFields.includes('summary')) {
        initialField = 'summary';
      } else if (node.availableFields.includes('body')) {
        initialField = 'body';
      } else if (node.availableFields.length > 0) {
        initialField = node.availableFields[0];
      } else {
        // Single structured field - stay in overview to show it
        initialField = '__overview__';
      }
    }
    
    // Remap special fields to actual prose field for initial content load
    let proseFieldToLoad = initialField;
    if (initialField === '__overview__' || initialField === '__content__' || initialField === '__attributes__') {
      // For overview and structured fields, load the primary prose field (summary or body)
      // This ensures the prose editor has content even if we're showing structured view
      proseFieldToLoad = node.availableFields.includes('summary') ? 'summary' : (node.proseField || 'body');
    }
    
    let prose: string;
    // Handle special fields (attributes, content sections) - they don't have prose content
    if (proseFieldToLoad.startsWith('__')) {
      prose = '';
    } else if (isMarkdownFile(fileName)) {
      // For markdown files, extract field from frontmatter or body
      if (proseFieldToLoad === 'body') {
        prose = codexDoc.rootNode?.proseValue ?? '';
      } else if (proseFieldToLoad === 'summary') {
        // For summary field, get from frontmatter
        const frontmatter = codexDoc.frontmatter as Record<string, unknown> | undefined;
        prose = (frontmatter?.summary as string) ?? '';
      } else {
        // For any other fields, try frontmatter
        const frontmatter = codexDoc.frontmatter as Record<string, unknown> | undefined;
        prose = (frontmatter?.[proseFieldToLoad] as string) ?? '';
      }
    } else {
      prose = getNodeProse(codexDoc, node, proseFieldToLoad);
    }
    
    // Create new panel in the ACTIVE editor group (same frame, new tab)
    let panel = vscode.window.createWebviewPanel(
      'chapterwiseCodexWriter',
      `üñãÔ∏è ${node.name || 'Writer'}`,
      vscode.ViewColumn.Active,  // Opens in current editor group as new tab
      {
        enableScripts: true,
        retainContextWhenHidden: true,
        localResourceRoots: [
          vscode.Uri.joinPath(this.context.extensionUri, 'media'),
        ],
      }
    );
    
    this.panels.set(panelKey, panel);
    
    // Set initial HTML with remembered field
    panel.webview.html = this.getWebviewHtml(panel.webview, node, prose, initialField);
    
    // Store initial stats and update status bar
    const initialStats = this.calculateStats(prose, node.name, initialField);
    this.updateStatsForPanel(panelKey, panel, initialStats);
    
    // Track current field for this panel
    let currentField = initialField;
    let currentAttributes: CodexAttribute[] = node.attributes || [];
    let currentContentSections: CodexContentSection[] = node.contentSections || [];
    
    // Listen for panel visibility/focus changes
    const viewStateDisposable = panel.onDidChangeViewState(() => {
      // Update status bar whenever any panel's state changes
      this.updateStatusBarForActivePanel();
    });
    
    // Handle messages from webview (closure captures node and documentUri)
    panel.webview.onDidReceiveMessage(
      async (message) => {
        switch (message.type) {
          case 'save':
            const fieldToSave = message.field || currentField;
            await this.handleSave(documentUri, node, message.text, fieldToSave);
            
            // Update stored stats
            const saveStats = this.calculateStats(message.text, node.name, fieldToSave);
            this.updateStatsForPanel(panelKey, panel, saveStats);
            
            panel.webview.postMessage({ type: 'saved' });
            break;
          
          case 'contentChanged':
            // New message type for real-time updates
            const contentStats = this.calculateStats(message.text, node.name, currentField);
            this.updateStatsForPanel(panelKey, panel, contentStats);
            break;
          
          case 'renameName':
            await this.handleRenameName(documentUri, node, message.name, panel);
            break;
            
          case 'switchField':
            currentField = message.field;
            this.lastSelectedField = message.field;  // Remember across node switches
            
            // Only fetch prose content for regular fields (not attributes/content)
            if (message.field !== '__attributes__' && message.field !== '__content__') {
              // Read file directly - DON'T open in VS Code text editor
              const filePath = documentUri.fsPath;
              const text = fs.readFileSync(filePath, 'utf-8');
              
              const parsed = isMarkdownFile(fileName)
                ? parseMarkdownAsCodex(text, fileName)
                : parseCodex(text);
              
              if (parsed) {
                let fieldContent: string;
                
                if (isMarkdownFile(fileName)) {
                  // For markdown files, extract field from frontmatter or body
                  if (message.field === 'body') {
                    fieldContent = parsed.rootNode?.proseValue ?? '';
                  } else {
                    // For summary and other fields, get from frontmatter
                    const frontmatter = parsed.frontmatter as Record<string, unknown> | undefined;
                    fieldContent = (frontmatter?.[message.field] as string) ?? '';
                  }
                } else {
                  // For codex files, use getNodeProse
                  fieldContent = getNodeProse(parsed, node, message.field);
                }
                
                panel.webview.postMessage({ type: 'fieldContent', text: fieldContent, field: message.field });
              }
            }
            break;
            
          case 'requestContent':
            // Read file directly - DON'T open in VS Code text editor
            const filePathReq = documentUri.fsPath;
            const textReq = fs.readFileSync(filePathReq, 'utf-8');
            const parsedReq = isMarkdownFile(fileName)
              ? parseMarkdownAsCodex(textReq, fileName)
              : parseCodex(textReq);
            if (parsedReq) {
              let currentProse: string;
              if (isMarkdownFile(fileName)) {
                // For markdown files, extract field from frontmatter or body
                if (currentField === 'body') {
                  currentProse = parsedReq.rootNode?.proseValue ?? '';
                } else {
                  // For summary and other fields, get from frontmatter
                  const frontmatter = parsedReq.frontmatter as Record<string, unknown> | undefined;
                  currentProse = (frontmatter?.[currentField] as string) ?? '';
                }
              } else {
                // For codex files, use getNodeProse
                currentProse = getNodeProse(parsedReq, node, currentField);
              }
              panel.webview.postMessage({ type: 'content', text: currentProse });
            }
            break;
            
          // Attributes - batch save (local state is managed in webview for instant UI)
          case 'saveAttributes':
            // Receive full array from webview and save once
            currentAttributes = message.attributes || [];
            await this.handleSaveAttributes(documentUri, node, currentAttributes);
            panel.webview.postMessage({ type: 'saveComplete' });
            break;
            
          // Content Sections - batch save (local state is managed in webview for instant UI)
          case 'saveContentSections':
            // Receive full array from webview and save once
            currentContentSections = message.sections || [];
            await this.handleSaveContentSections(documentUri, node, currentContentSections);
            panel.webview.postMessage({ type: 'saveComplete' });
            break;
        }
      },
      undefined,
      this.context.subscriptions
    );
    
    // Listen for VS Code theme changes (affects "theme" mode)
    const themeChangeDisposable = vscode.window.onDidChangeActiveColorTheme(() => {
      const vscodeThemeKind = this.getVSCodeThemeKind();
      const themeSetting = this.getThemeSetting();
      
      // Update this specific panel
      panel.webview.postMessage({ 
        type: 'themeChanged',
        themeSetting: themeSetting,
        vscodeTheme: vscodeThemeKind
      });
    });
    
    // Listen for settings changes
    const configChangeDisposable = vscode.workspace.onDidChangeConfiguration((e) => {
      if (e.affectsConfiguration('chapterwiseCodex.writerView.theme')) {
        const themeSetting = this.getThemeSetting();
        const vscodeThemeKind = this.getVSCodeThemeKind();
        
        // Update this specific panel
        panel.webview.postMessage({ 
          type: 'themeChanged',
          themeSetting: themeSetting,
          vscodeTheme: vscodeThemeKind
        });
      }
    });
    
    // Handle panel disposal
    panel.onDidDispose(() => {
      this.panels.delete(panelKey);
      this.panelStats.delete(panelKey);
      
      // Update status bar (will show another Writer View if one exists, or hide)
      this.updateStatusBarForActivePanel();
      
      themeChangeDisposable.dispose();
      configChangeDisposable.dispose();
      viewStateDisposable.dispose();
    });
  }
  
  /**
   * Open Writer View for a specific field of a node
   */
  async openWriterViewForField(node: CodexNode, documentUri: vscode.Uri, targetField: string): Promise<void> {
    // Create a unique key for this panel (same as openWriterView)
    const panelKey = `${documentUri.toString()}#${node.id || node.path.join('/')}`;
    
    // Check if panel already exists
    let existingPanel = this.panels.get(panelKey);
    if (existingPanel) {
      existingPanel.reveal(vscode.ViewColumn.Active);
      // If panel exists, send message to switch to the target field
      existingPanel.webview.postMessage({ 
        type: 'switchToField', 
        field: targetField 
      });
      return;
    }
    
    // Read file directly - DON'T open in VS Code text editor
    const fileName = documentUri.fsPath;
    const text = fs.readFileSync(fileName, 'utf-8');
    
    // Use appropriate parser based on file type
    const codexDoc = isMarkdownFile(fileName)
      ? parseMarkdownAsCodex(text, fileName)
      : parseCodex(text);
      
    if (!codexDoc) {
      const fileType = isMarkdownFile(fileName) ? 'Markdown' : 'Codex';
      vscode.window.showErrorMessage(`Unable to parse ${fileType} document`);
      return;
    }
    
    // Remap special fields to actual prose field for initial content load
    let proseFieldToLoad = targetField;
    if (targetField === '__overview__' || targetField === '__content__' || targetField === '__attributes__') {
      // For overview and structured fields, load the primary prose field (summary or body)
      // This ensures the prose editor has content even if we're showing structured view
      proseFieldToLoad = node.availableFields.includes('summary') ? 'summary' : (node.proseField || 'body');
    }
    
    // Get prose value for the target field
    let prose: string;
    if (proseFieldToLoad.startsWith('__')) {
      prose = '';
    } else if (isMarkdownFile(fileName)) {
      // For markdown files, extract field from frontmatter or body
      if (proseFieldToLoad === 'body') {
        prose = codexDoc.rootNode?.proseValue ?? '';
      } else {
        // For summary and other fields, get from frontmatter
        const frontmatter = codexDoc.frontmatter as Record<string, unknown> | undefined;
        prose = (frontmatter?.[proseFieldToLoad] as string) ?? '';
      }
    } else {
      prose = getNodeProse(codexDoc, node, proseFieldToLoad);
    }
    
    // Create new panel
    let panel = vscode.window.createWebviewPanel(
      'chapterwiseCodexWriter',
      `üñãÔ∏è ${node.name || 'Writer'}`,
      vscode.ViewColumn.Active,
      {
        enableScripts: true,
        retainContextWhenHidden: true,
        localResourceRoots: [
          vscode.Uri.joinPath(this.context.extensionUri, 'media'),
        ],
      }
    );
    
    this.panels.set(panelKey, panel);
    
    // Set initial HTML with the target field selected
    panel.webview.html = this.getWebviewHtml(panel.webview, node, prose, targetField);
    
    // Store initial stats and update status bar
    const initialStats = this.calculateStats(prose, node.name, targetField);
    this.updateStatsForPanel(panelKey, panel, initialStats);
    
    // Track current field for this panel
    let currentField = targetField;
    let currentAttributes: CodexAttribute[] = node.attributes || [];
    let currentContentSections: CodexContentSection[] = node.contentSections || [];
    
    // Listen for panel visibility/focus changes
    const viewStateDisposable2 = panel.onDidChangeViewState(() => {
      // Update status bar whenever any panel's state changes
      this.updateStatusBarForActivePanel();
    });
    
    // Handle messages from webview (same handlers as openWriterView)
    panel.webview.onDidReceiveMessage(
      async (message) => {
        switch (message.type) {
          case 'save':
            const fieldToSave = message.field || currentField;
            await this.handleSave(documentUri, node, message.text, fieldToSave);
            
            // Update stored stats
            const saveStats = this.calculateStats(message.text, node.name, fieldToSave);
            this.updateStatsForPanel(panelKey, panel, saveStats);
            
            panel.webview.postMessage({ type: 'saved' });
            break;
          
          case 'contentChanged':
            // New message type for real-time updates
            const contentStats = this.calculateStats(message.text, node.name, currentField);
            this.updateStatsForPanel(panelKey, panel, contentStats);
            break;
          
          case 'switchField':
            currentField = message.field;
            this.lastSelectedField = message.field;
            
            if (message.field !== '__attributes__' && message.field !== '__content__') {
              // Read file directly - DON'T open in VS Code text editor
              const filePath = documentUri.fsPath;
              const text = fs.readFileSync(filePath, 'utf-8');
              
              const parsed = isMarkdownFile(fileName)
                ? parseMarkdownAsCodex(text, fileName)
                : parseCodex(text);
              
              if (parsed) {
                let fieldContent: string;
                
                if (isMarkdownFile(fileName)) {
                  // For markdown files, extract field from frontmatter or body
                  if (message.field === 'body') {
                    fieldContent = parsed.rootNode?.proseValue ?? '';
                  } else {
                    // For summary and other fields, get from frontmatter
                    const frontmatter = parsed.frontmatter as Record<string, unknown> | undefined;
                    fieldContent = (frontmatter?.[message.field] as string) ?? '';
                  }
                } else {
                  // For codex files, use getNodeProse
                  fieldContent = getNodeProse(parsed, node, message.field);
                }
                
                panel.webview.postMessage({ type: 'fieldContent', text: fieldContent, field: message.field });
              }
            }
            break;
            
          case 'requestContent':
            // Read file directly - DON'T open in VS Code text editor
            const filePathReq = documentUri.fsPath;
            const textReq = fs.readFileSync(filePathReq, 'utf-8');
            const parsedReq = isMarkdownFile(fileName)
              ? parseMarkdownAsCodex(textReq, fileName)
              : parseCodex(textReq);
            if (parsedReq) {
              let currentProse: string;
              if (isMarkdownFile(fileName)) {
                // For markdown files, extract field from frontmatter or body
                if (currentField === 'body') {
                  currentProse = parsedReq.rootNode?.proseValue ?? '';
                } else {
                  // For summary and other fields, get from frontmatter
                  const frontmatter = parsedReq.frontmatter as Record<string, unknown> | undefined;
                  currentProse = (frontmatter?.[currentField] as string) ?? '';
                }
              } else {
                // For codex files, use getNodeProse
                currentProse = getNodeProse(parsedReq, node, currentField);
              }
              panel.webview.postMessage({ type: 'content', text: currentProse });
            }
            break;
            
          case 'saveAttributes':
            currentAttributes = message.attributes || [];
            await this.handleSaveAttributes(documentUri, node, currentAttributes);
            panel.webview.postMessage({ type: 'saveComplete' });
            break;
            
          case 'saveContentSections':
            currentContentSections = message.sections || [];
            await this.handleSaveContentSections(documentUri, node, currentContentSections);
            panel.webview.postMessage({ type: 'saveComplete' });
            break;
        }
      },
      undefined,
      this.context.subscriptions
    );
    
    // Listen for VS Code theme changes (affects "theme" mode)
    const themeChangeDisposable2 = vscode.window.onDidChangeActiveColorTheme(() => {
      const vscodeThemeKind = this.getVSCodeThemeKind();
      const themeSetting = this.getThemeSetting();
      
      // Update this specific panel
      panel.webview.postMessage({ 
        type: 'themeChanged',
        themeSetting: themeSetting,
        vscodeTheme: vscodeThemeKind
      });
    });
    
    // Listen for settings changes
    const configChangeDisposable2 = vscode.workspace.onDidChangeConfiguration((e) => {
      if (e.affectsConfiguration('chapterwiseCodex.writerView.theme')) {
        const themeSetting = this.getThemeSetting();
        const vscodeThemeKind = this.getVSCodeThemeKind();
        
        // Update this specific panel
        panel.webview.postMessage({ 
          type: 'themeChanged',
          themeSetting: themeSetting,
          vscodeTheme: vscodeThemeKind
        });
      }
    });
    
    // Handle panel disposal
    panel.onDidDispose(() => {
      this.panels.delete(panelKey);
      this.panelStats.delete(panelKey);
      
      // Update status bar (will show another Writer View if one exists, or hide)
      this.updateStatusBarForActivePanel();
      
      themeChangeDisposable2.dispose();
      configChangeDisposable2.dispose();
      viewStateDisposable2.dispose();
    });
  }
  
  /**
   * Handle save from webview
   */
  private async handleSave(
    documentUri: vscode.Uri,
    node: CodexNode,
    newText: string,
    field?: string
  ): Promise<void> {
    try {
      const document = await vscode.workspace.openTextDocument(documentUri);
      const fileName = documentUri.fsPath;
      const originalText = document.getText();
      
      let newDocText: string;
      
      // Handle markdown files (Codex Lite) differently
      if (isMarkdownFile(fileName)) {
        const codexDoc = parseMarkdownAsCodex(originalText, fileName);
        if (!codexDoc) {
          vscode.window.showErrorMessage('Unable to parse Markdown document for saving');
          return;
        }
        
        // For markdown, handle body and summary differently
        const fieldToSave = field || 'body';
        if (fieldToSave === 'summary') {
          // Save to frontmatter for summary field
          newDocText = setMarkdownFrontmatterField(originalText, 'summary', newText);
        } else {
          // Update the body (preserving frontmatter)
        newDocText = setMarkdownNodeProse(originalText, newText, codexDoc.frontmatter);
        }
      } else {
        // Standard Codex file handling
        const codexDoc = parseCodex(originalText);
        if (!codexDoc) {
          vscode.window.showErrorMessage('Unable to parse Codex document for saving');
          return;
        }
        
        // Generate new document text
        newDocText = setNodeProse(codexDoc, node, newText, field);
      }
      
      // Apply the edit
      const edit = new vscode.WorkspaceEdit();
      const fullRange = new vscode.Range(
        document.positionAt(0),
        document.positionAt(originalText.length)
      );
      edit.replace(documentUri, fullRange, newDocText);
      
      const success = await vscode.workspace.applyEdit(edit);
      if (success) {
        await document.save();
        const fileType = isMarkdownFile(fileName) ? 'Markdown' : 'Codex';
        vscode.window.setStatusBarMessage(`‚úì ${fileType} saved`, 2000);
      } else {
        vscode.window.showErrorMessage('Failed to save changes');
      }
    } catch (error) {
      vscode.window.showErrorMessage(`Save failed: ${error}`);
    }
  }
  
  /**
   * Handle inline rename of the node name/title
   */
  private async handleRenameName(
    documentUri: vscode.Uri,
    node: CodexNode,
    newName: string,
    panel: vscode.WebviewPanel
  ): Promise<void> {
    const trimmed = (newName || '').trim();
    if (!trimmed) {
      panel.webview.postMessage({ type: 'nameUpdateError', error: 'Name cannot be empty.' });
      return;
    }
    
    try {
      const filePath = documentUri.fsPath;
      const fileName = filePath.toLowerCase();
      const originalText = fs.readFileSync(filePath, 'utf-8');
      let newDocText: string | null = null;
      
      if (isMarkdownFile(fileName)) {
        // Codex Lite: store name in frontmatter
        newDocText = setMarkdownFrontmatterField(originalText, 'name', trimmed);
      } else {
        const codexDoc = parseCodex(originalText);
        if (!codexDoc) {
          panel.webview.postMessage({ type: 'nameUpdateError', error: 'Unable to parse document for renaming.' });
          return;
        }
        newDocText = setNodeName(codexDoc, node, trimmed);
      }
      
      if (!newDocText) {
        panel.webview.postMessage({ type: 'nameUpdateError', error: 'Rename failed: could not update text.' });
        return;
      }
      
      fs.writeFileSync(filePath, newDocText, 'utf-8');
      
      // Update in-memory node and panel title for consistency
      node.name = trimmed;
      panel.title = `‚úçÔ∏è ${trimmed || 'Writer'}`;
      
      panel.webview.postMessage({ type: 'nameUpdated', name: trimmed });
    } catch (error) {
      console.error('Rename failed:', error);
      panel.webview.postMessage({ type: 'nameUpdateError', error: 'Failed to rename. See console for details.' });
    }
  }
  
  /**
   * Handle saving attributes
   */
  private async handleSaveAttributes(
    documentUri: vscode.Uri,
    node: CodexNode,
    attributes: CodexAttribute[]
  ): Promise<void> {
    try {
      const document = await vscode.workspace.openTextDocument(documentUri);
      const codexDoc = parseCodex(document.getText());
      
      if (!codexDoc) {
        vscode.window.showErrorMessage('Unable to parse Codex document for saving');
        return;
      }
      
      const newDocText = setNodeAttributes(codexDoc, node, attributes);
      
      const edit = new vscode.WorkspaceEdit();
      const fullRange = new vscode.Range(
        document.positionAt(0),
        document.positionAt(document.getText().length)
      );
      edit.replace(documentUri, fullRange, newDocText);
      
      const success = await vscode.workspace.applyEdit(edit);
      if (success) {
        await document.save();
        vscode.window.setStatusBarMessage('‚úì Attributes saved', 2000);
      }
    } catch (error) {
      vscode.window.showErrorMessage(`Save failed: ${error}`);
    }
  }
  
  /**
   * Handle saving content sections
   */
  private async handleSaveContentSections(
    documentUri: vscode.Uri,
    node: CodexNode,
    contentSections: CodexContentSection[]
  ): Promise<void> {
    try {
      const document = await vscode.workspace.openTextDocument(documentUri);
      const codexDoc = parseCodex(document.getText());
      
      if (!codexDoc) {
        vscode.window.showErrorMessage('Unable to parse Codex document for saving');
        return;
      }
      
      const newDocText = setNodeContentSections(codexDoc, node, contentSections);
      
      const edit = new vscode.WorkspaceEdit();
      const fullRange = new vscode.Range(
        document.positionAt(0),
        document.positionAt(document.getText().length)
      );
      edit.replace(documentUri, fullRange, newDocText);
      
      const success = await vscode.workspace.applyEdit(edit);
      if (success) {
        await document.save();
        vscode.window.setStatusBarMessage('‚úì Content saved', 2000);
      }
    } catch (error) {
      vscode.window.showErrorMessage(`Save failed: ${error}`);
    }
  }
  
  /**
   * Generate the webview HTML
   */
  private getWebviewHtml(
    webview: vscode.Webview,
    node: CodexNode,
    prose: string,
    initialField: string = 'body'
  ): string {
    const nonce = this.getNonce();
    const themeSetting = this.getThemeSetting();
    const vscodeThemeKind = this.getVSCodeThemeKind();
    
    // Escape prose for safe HTML injection
    const escapedProse = this.escapeHtml(prose);
    
    // Word count
    const wordCount = prose.trim() ? prose.trim().split(/\s+/).length : 0;
    
    return /* html */ `<!DOCTYPE html>
<html lang="en" data-theme-setting="${themeSetting}" data-vscode-theme="${vscodeThemeKind}">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="Content-Security-Policy" content="default-src 'none'; style-src ${webview.cspSource} 'unsafe-inline'; script-src 'nonce-${nonce}';">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Writer: ${this.escapeHtml(node.name)}</title>
  <style>
    :root {
      /* Default to dark theme as fallback */
      --bg-primary: #0d1117;
      --bg-secondary: #161b22;
      --bg-editor: #0d1117;
      --text-primary: #e6edf3;
      --text-secondary: #8b949e;
      --text-muted: #6e7681;
      --border-color: #30363d;
      --accent: #58a6ff;
      --accent-hover: #79c0ff;
      --success: #3fb950;
    }
    
    /* Light theme colors */
    [data-theme-setting="light"] {
      --bg-primary: #ffffff;
      --bg-secondary: #f6f8fa;
      --bg-editor: #ffffff;
      --text-primary: #24292f;
      --text-secondary: #57606a;
      --text-muted: #6e7781;
      --border-color: #d0d7de;
      --accent: #0969da;
      --accent-hover: #0860ca;
      --success: #1a7f37;
    }
    
    /* Dark theme colors (explicit) */
    [data-theme-setting="dark"] {
      --bg-primary: #0d1117;
      --bg-secondary: #161b22;
      --bg-editor: #0d1117;
      --text-primary: #e6edf3;
      --text-secondary: #8b949e;
      --text-muted: #6e7681;
      --border-color: #30363d;
      --accent: #58a6ff;
      --accent-hover: #79c0ff;
      --success: #3fb950;
    }
    
    /* Theme mode - use VS Code CSS variables */
    [data-theme-setting="theme"] {
      --bg-primary: var(--vscode-editor-background);
      --bg-secondary: var(--vscode-sideBar-background);
      --bg-editor: var(--vscode-editor-background);
      --text-primary: var(--vscode-editor-foreground);
      --text-secondary: var(--vscode-descriptionForeground);
      --text-muted: var(--vscode-disabledForeground);
      --border-color: var(--vscode-panel-border);
      --accent: var(--vscode-focusBorder);
      --accent-hover: var(--vscode-button-hoverBackground);
      --success: var(--vscode-testing-iconPassed);
    }
    
    /* System theme detection via CSS media query */
    @media (prefers-color-scheme: light) {
      [data-theme-setting="system"] {
        --bg-primary: #ffffff;
        --bg-secondary: #f6f8fa;
        --bg-editor: #ffffff;
        --text-primary: #24292f;
        --text-secondary: #57606a;
        --text-muted: #6e7781;
        --border-color: #d0d7de;
        --accent: #0969da;
        --accent-hover: #0860ca;
        --success: #1a7f37;
      }
    }
    
    @media (prefers-color-scheme: dark) {
      [data-theme-setting="system"] {
        --bg-primary: #0d1117;
        --bg-secondary: #161b22;
        --bg-editor: #0d1117;
        --text-primary: #e6edf3;
        --text-secondary: #8b949e;
        --text-muted: #6e7681;
        --border-color: #30363d;
        --accent: #58a6ff;
        --accent-hover: #79c0ff;
        --success: #3fb950;
      }
    }
    
    * {
      box-sizing: border-box;
    }
    
    body {
      font-family: 'Charter', 'Georgia', 'Cambria', 'Times New Roman', serif;
      margin: 0;
      padding: 0;
      background: var(--bg-primary);
      color: var(--text-primary);
      line-height: 1.7;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
    }
    
    /* Header */
    .header {
      background: var(--bg-secondary);
      border-bottom: 1px solid var(--border-color);
      padding: 0.75rem 1.5rem;
      display: flex;
      justify-content: space-between;
      align-items: center;
      position: sticky;
      top: 0;
      z-index: 100;
    }
    
    .header-left {
      display: flex;
      align-items: center;
      gap: 1rem;
    }
    
    .node-info {
      display: flex;
      flex-direction: column;
      gap: 0.125rem;
    }
    
    .node-type-row {
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }
    
    .node-type {
      font-family: 'SF Mono', 'Consolas', 'Monaco', monospace;
      font-size: 0.7rem;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      color: var(--text-muted);
    }
    
    .field-selector {
      font-family: 'SF Mono', 'Consolas', 'Monaco', monospace;
      font-size: 0.65rem;
      color: var(--accent);
      background: rgba(88, 166, 255, 0.1);
      border: 1px solid rgba(88, 166, 255, 0.3);
      padding: 0.125rem 0.375rem;
      border-radius: 3px;
      cursor: pointer;
      outline: none;
      transition: all 0.15s ease;
    }
    
    .field-selector:hover {
      background: rgba(88, 166, 255, 0.2);
      border-color: var(--accent);
    }
    
    .field-selector:focus {
      border-color: var(--accent);
      box-shadow: 0 0 0 2px rgba(88, 166, 255, 0.2);
    }
    
    .field-selector option {
      background: var(--bg-secondary);
      color: var(--text-primary);
    }
    
    .node-name {
      font-size: 1rem;
      font-weight: 600;
      color: var(--text-primary);
    }
    
    .node-name.editable {
      cursor: text;
      user-select: none;
      transition: opacity 0.15s ease;
    }
    
    .node-name.editable:hover {
      opacity: 0.9;
    }
    
    .node-name-container {
      position: relative;
    }
    
    .node-name.editing-hidden {
      display: none;
    }
    
    .node-name-edit {
      display: none;
      font-size: 1rem;
      font-weight: 600;
      color: var(--text-primary);
      background: transparent;
      border: none;
      padding: 0;
      margin: 0;
      outline: none;
      word-break: break-word;
      white-space: pre-wrap;
    }
    
    .node-name-edit:focus {
      outline: none;
    }
    
    .node-name-edit.editing-active {
      display: inline;
    }
    
    /* Attributes Editor Styles */
    .structured-editor {
      display: none;
      flex: 1;
      padding: 1.5rem;
      overflow-y: auto;
    }
    
    .structured-editor.active {
      display: block;
    }
    
    .structured-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 1rem;
      padding-bottom: 0.5rem;
      border-bottom: 1px solid var(--border-color);
    }
    
    .structured-title {
      font-family: 'SF Mono', 'Consolas', 'Monaco', monospace;
      font-size: 0.75rem;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      color: var(--text-muted);
    }
    
    .add-btn {
      background: rgba(88, 166, 255, 0.1);
      color: var(--accent);
      border: 1px solid rgba(88, 166, 255, 0.3);
      padding: 0.375rem 0.75rem;
      border-radius: 4px;
      font-size: 0.75rem;
      cursor: pointer;
      transition: all 0.15s ease;
    }
    
    .add-btn:hover {
      background: rgba(88, 166, 255, 0.2);
      border-color: var(--accent);
    }
    
    /* Attributes Table */
    .attr-table {
      width: 100%;
      border-collapse: collapse;
      font-size: 0.875rem;
    }
    
    .attr-table th {
      text-align: left;
      padding: 0.5rem;
      font-family: 'SF Mono', 'Consolas', 'Monaco', monospace;
      font-size: 0.7rem;
      text-transform: uppercase;
      color: var(--text-muted);
      border-bottom: 1px solid var(--border-color);
      font-weight: 500;
    }
    
    .attr-table td {
      padding: 0.375rem 0.5rem;
      border-bottom: 1px solid var(--border-color);
      vertical-align: middle;
    }
    
    .attr-table tr:hover {
      background: rgba(255, 255, 255, 0.02);
    }
    
    .attr-input {
      background: transparent;
      border: 1px solid transparent;
      color: var(--text-primary);
      padding: 0.25rem 0.375rem;
      border-radius: 3px;
      font-size: 0.875rem;
      width: 100%;
      transition: all 0.15s ease;
    }
    
    .attr-input:hover {
      border-color: var(--border-color);
    }
    
    .attr-input:focus {
      outline: none;
      border-color: var(--accent);
      background: rgba(88, 166, 255, 0.05);
    }
    
    .attr-input.key-input {
      font-family: 'SF Mono', 'Consolas', 'Monaco', monospace;
      font-size: 0.8rem;
    }
    
    .type-select {
      background: transparent;
      border: 1px solid var(--border-color);
      color: var(--text-muted);
      padding: 0.375rem 0.5rem;
      border-radius: 3px;
      font-size: 0.75rem;
      cursor: pointer;
      transition: all 0.15s ease;
      min-width: 80px;
    }
    
    .type-select:hover {
      border-color: var(--text-secondary);
    }
    
    .type-select:focus {
      outline: none;
      border-color: var(--accent);
      background: rgba(88, 166, 255, 0.05);
    }
    
    .type-select option {
      background: var(--bg-secondary);
      color: var(--text-primary);
    }
    
    .delete-btn {
      background: transparent;
      border: none;
      color: var(--text-muted);
      cursor: pointer;
      padding: 0.25rem;
      border-radius: 3px;
      opacity: 0.5;
      transition: all 0.15s ease;
    }
    
    .delete-btn:hover {
      opacity: 1;
      color: #f85149;
      background: rgba(248, 81, 73, 0.1);
    }
    
    /* === SHARED UTILITIES === */
    
    /* Shared: Sans-serif name font */
    .name-field {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      font-weight: 500;
      color: var(--text-primary);
    }
    
    /* Shared: Inline editable name/field */
    .inline-editable {
      cursor: pointer;
      padding: 2px 4px;
      border-radius: 3px;
      transition: background 0.15s ease;
    }
    
    .inline-editable:hover {
      background: rgba(255, 255, 255, 0.1);
    }
    
    .inline-editable.editing-hidden {
      display: none;
    }
    
    /* Shared: Inline edit input */
    .inline-edit-field {
      display: none;
      padding: 2px 4px;
      border: 1px solid var(--accent);
      border-radius: 3px;
      background: var(--bg-primary);
      min-width: 100px;
    }
    
    .inline-edit-field.editing-active {
      display: inline-block;
    }
    
    .inline-edit-field:focus {
      outline: none;
    }
    
    /* Shared: Key badge */
    .key-badge {
      font-family: 'SF Mono', 'Consolas', 'Monaco', monospace;
      font-size: 0.7rem;
      color: var(--text-muted);
      background: rgba(255, 255, 255, 0.05);
      padding: 0.125rem 0.375rem;
      border-radius: 3px;
    }
    
    /* Shared: Dropdown menu system */
    .dropdown-menu {
      position: relative;
    }
    
    .dropdown-menu .menu-btn {
      background: transparent;
      border: none;
      color: var(--text-muted);
      cursor: pointer;
      padding: 0.25rem 0.5rem;
      border-radius: 3px;
      opacity: 0.5;
      transition: all 0.15s ease;
      font-size: 1.2rem;
      line-height: 1;
    }
    
    .dropdown-menu .menu-btn:hover {
      opacity: 1;
      background: rgba(255, 255, 255, 0.1);
    }
    
    .dropdown-menu.active .menu-btn {
      opacity: 1;
      background: rgba(255, 255, 255, 0.1);
    }
    
    .dropdown-menu .menu-dropdown {
      display: none;
      position: absolute;
      top: 100%;
      right: 0;
      margin-top: 0.25rem;
      background: var(--bg-secondary);
      border: 1px solid var(--border-color);
      border-radius: 4px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
      min-width: 120px;
      z-index: 1000;
    }
    
    .dropdown-menu.active .menu-dropdown {
      display: block;
    }
    
    /* === END SHARED UTILITIES === */
    
    /* Attribute Cards (new card-based layout) */
    .attr-card {
      margin-bottom: 0.75rem;
      border: 1px solid var(--border-color);
      border-radius: 6px;
      background: var(--bg-secondary);
      padding: 0.75rem 1rem;
      transition: background 0.15s ease;
    }
    
    .attr-card:hover {
      background: rgba(255, 255, 255, 0.02);
    }
    
    .attr-card-content {
      display: flex;
      align-items: center;
      gap: 1rem;
    }
    
    .attr-title {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      flex: 0 0 auto;
      min-width: 200px;
    }
    
    .attr-name {
      font-size: 0.875rem;
    }
    
    .attr-name-edit {
      font-size: 0.875rem;
    }
    
    .attr-value-input {
      flex: 1;
      background: transparent;
      border: 1px solid var(--border-color);
      color: var(--text-primary);
      padding: 0.375rem 0.5rem;
      border-radius: 3px;
      font-size: 0.875rem;
      transition: all 0.15s ease;
    }
    
    .attr-value-input:hover {
      border-color: var(--text-secondary);
    }
    
    .attr-value-input:focus {
      outline: none;
      border-color: var(--accent);
      background: rgba(88, 166, 255, 0.05);
    }
    
    /* Menu item styles (shared by both dropdowns) */
    .menu-item {
      display: block;
      width: 100%;
      background: transparent;
      border: none;
      color: var(--text-primary);
      cursor: pointer;
      padding: 0.5rem 0.75rem;
      text-align: left;
      transition: background 0.15s ease;
      font-size: 0.875rem;
    }
    
    .menu-item:hover {
      background: rgba(255, 255, 255, 0.1);
    }
    
    .menu-item.delete-item {
      color: #ff6b6b;
    }
    
    .menu-item.delete-item:hover {
      background: rgba(255, 50, 50, 0.1);
    }
    
    .empty-state {
      text-align: center;
      padding: 3rem;
      color: var(--text-muted);
    }
    
    .empty-state-icon {
      font-size: 2rem;
      margin-bottom: 0.5rem;
      opacity: 0.5;
    }
    
    /* Content Sections Editor */
    .content-section {
      margin-bottom: 1rem;
      border: 1px solid var(--border-color);
      border-radius: 6px;
      overflow: visible;
    }
    
    .content-section-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 0.75rem 1rem;
      background: var(--bg-secondary);
      cursor: pointer;
      user-select: none;
      border-radius: 6px;
      position: relative;
    }
    
    .content-section.expanded .content-section-header {
      border-radius: 6px 6px 0 0;
    }
    
    .content-section-header:hover {
      background: rgba(255, 255, 255, 0.03);
    }
    
    .content-section-title {
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }
    
    .content-section-toggle {
      color: var(--text-muted);
      transition: transform 0.2s ease;
    }
    
    .content-section.expanded .content-section-toggle {
      transform: rotate(90deg);
    }
    
    /* Content section name and key now use shared utility classes */
    
    .content-section-body {
      display: none;
      padding: 1rem;
      border-top: 1px solid var(--border-color);
      border-radius: 0 0 6px 6px;
      overflow: hidden;
    }
    
    .content-section.expanded .content-section-body {
      display: block;
    }
    
    .content-section-meta {
      display: flex;
      gap: 1rem;
      margin-bottom: 0.75rem;
    }
    
    .content-section-meta label {
      font-size: 0.7rem;
      color: var(--text-muted);
      text-transform: uppercase;
    }
    
    .content-section-meta input {
      background: transparent;
      border: 1px solid var(--border-color);
      color: var(--text-primary);
      padding: 0.25rem 0.5rem;
      border-radius: 3px;
      font-size: 0.875rem;
      margin-top: 0.25rem;
      width: 100%;
    }
    
    .content-section-meta input:focus {
      outline: none;
      border-color: var(--accent);
    }
    
    .content-textarea {
      width: 100%;
      min-height: 200px;
      background: var(--bg-primary);
      border: 1px solid var(--border-color);
      color: var(--text-primary);
      padding: 1rem;
      border-radius: 4px;
      font-family: 'Charter', 'Georgia', 'Cambria', 'Times New Roman', serif;
      font-size: 1rem;
      line-height: 1.6;
      resize: vertical;
      box-sizing: border-box;
    }
    
    .content-textarea:focus {
      outline: none;
      border-color: var(--accent);
    }
    
    .header-right {
      display: flex;
      align-items: center;
      gap: 1rem;
    }
    
    .word-count {
      font-family: 'SF Mono', 'Consolas', 'Monaco', monospace;
      font-size: 0.75rem;
      color: var(--text-muted);
    }
    
    .save-btn {
      width: 32px;
      height: 32px;
      border-radius: 50%;
      border: 1.5px solid var(--text-muted); /* Grey - default (clean state) */
      background: transparent;
      color: var(--text-muted);
      padding: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: border-color 0.2s ease, color 0.2s ease;
    }

    .save-btn .codicon {
      font-size: 16px;
      line-height: 0;
    }
    
    .save-btn:hover {
      border-color: var(--accent);
      color: var(--accent);
      background: rgba(88, 166, 255, 0.1);
    }
    
    .save-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    
    /* Blue outline when dirty (has unsaved changes) */
    .save-btn.dirty {
      border-color: var(--accent);
      color: var(--accent);
    }
    
    /* Green outline when just saved (brief flash) */
    .save-btn.saved-flash {
      border-color: var(--success);
      color: var(--success);
      animation: greenFlash 1s ease;
    }
    
    @keyframes greenFlash {
      0% { border-color: var(--success); color: var(--success); }
      100% { border-color: var(--text-muted); color: var(--text-muted); }
    }
    
    /* Editor container */
    .editor-container {
      flex: 1;
      display: flex;
      justify-content: center;
      padding: 2rem;
      overflow-y: auto;
    }
    
    .editor-wrapper {
      width: 100%;
      max-width: 700px;
    }
    
    /* The actual editor */
    #editor {
      font-family: 'Charter', 'Georgia', 'Cambria', 'Times New Roman', serif;
      font-size: 1.125rem;
      line-height: 1.8;
      color: var(--text-primary);
      background: transparent;
      border: none;
      outline: none;
      width: 100%;
      min-height: calc(100vh - 200px);
      resize: none;
      padding: 0;
      white-space: pre-wrap;
      word-wrap: break-word;
    }
    
    #editor:focus {
      outline: none;
    }
    
    /* Placeholder */
    #editor:empty:before {
      content: attr(data-placeholder);
      color: var(--text-muted);
      font-style: italic;
      pointer-events: none;
    }
    
    /* Footer */
    .footer {
      background: var(--bg-secondary);
      border-top: 1px solid var(--border-color);
      padding: 0.5rem 1.5rem;
      font-family: 'SF Mono', 'Consolas', 'Monaco', monospace;
      font-size: 0.7rem;
      color: var(--text-muted);
      display: flex;
      justify-content: space-between;
    }
    
    .keyboard-hint {
      display: flex;
      gap: 1rem;
    }
    
    .keyboard-hint kbd {
      background: var(--bg-primary);
      border: 1px solid var(--border-color);
      border-radius: 3px;
      padding: 0.125rem 0.375rem;
      font-family: inherit;
    }
    
    /* Scrollbar */
    ::-webkit-scrollbar {
      width: 8px;
    }
    
    ::-webkit-scrollbar-track {
      background: var(--bg-primary);
    }
    
    ::-webkit-scrollbar-thumb {
      background: var(--border-color);
      border-radius: 4px;
    }
    
    ::-webkit-scrollbar-thumb:hover {
      background: var(--text-muted);
    }
    
    /* === OVERVIEW MODE STYLES === */
    
    /* Default: Hide editors based on body class */
    body:not(.mode-prose) .editor-container {
      display: none;
    }
    
    body:not(.mode-structured) .structured-editor {
      display: none;
    }
    
    /* Prose mode: Show only prose editor */
    body.mode-prose .editor-container {
      display: flex;
    }
    
    /* Structured mode: Show attributes OR content */
    body.mode-structured .structured-editor.active {
      display: block;
    }
    
    /* === OVERVIEW MODE === */
    /* Show all three sections in vertical stack with uniform width */
    body.mode-overview .editor-container,
    body.mode-overview .structured-editor {
      display: block !important;
      width: 100%;
      max-width: 900px;
      margin: 0 auto 2rem;
      box-sizing: border-box;
    }
    
    /* Make prose editor look like a card */
    body.mode-overview .editor-container {
      background: var(--bg-secondary);
      border: 1px solid var(--border-color);
      border-radius: 6px;
      padding: 1.5rem;
      overflow: visible;
    }
    
    /* Add section header to prose editor in overview mode */
    body.mode-overview .editor-wrapper::before {
      content: 'Summary';
      display: block;
      font-size: 0.75rem;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      color: var(--text-muted);
      margin-bottom: 0.75rem;
      font-weight: 600;
    }
    
    /* Make attributes/content look like cards with same width */
    body.mode-overview .structured-editor {
      background: var(--bg-secondary);
      border: 1px solid var(--border-color);
      border-radius: 6px;
      overflow: hidden;
      padding: 0;
    }
    
    /* Ensure structured editor containers don't override width */
    body.mode-overview .structured-editor #attributesContainer,
    body.mode-overview .structured-editor #contentContainer {
      width: 100%;
      box-sizing: border-box;
    }
    
    /* Style structured headers in overview mode */
    body.mode-overview .structured-header {
      font-size: 0.75rem;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      color: var(--text-muted);
      font-weight: 600;
      padding: 0.75rem 1rem;
      border-bottom: 1px solid var(--border-color);
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    
    body.mode-overview .structured-title {
      flex: 1;
    }
    
    /* Make content sections collapsible in overview */
    body.mode-overview .content-section {
      margin-bottom: 0.5rem;
    }
    
    body.mode-overview .content-section-header {
      transition: background 0.15s ease;
    }
    
    body.mode-overview .content-section-header:hover {
      background: rgba(255, 255, 255, 0.05);
    }
    
    /* Adjust spacing in overview mode */
    body.mode-overview .editor-wrapper {
      max-width: 100%;
    }
    
    body.mode-overview #editor {
      min-height: 150px;
    }
    
    /* Hide empty attributes/content sections in overview mode */
    body.mode-overview #attributesEditor:has(.empty-state) {
      display: none !important;
    }
    
    body.mode-overview #contentEditor:has(.empty-state) {
      display: none !important;
    }
  </style>
</head>
<body>
  <div class="header">
    <div class="header-left">
      <div class="node-info">
        <div class="node-type-row">
          <span class="node-type">${this.escapeHtml(node.type)}</span>
          <select class="field-selector" id="fieldSelector">
            ${(() => {
              const options: string[] = [];
              
              // Check if entity has multiple fields to show overview option
              const hasMultipleFields = node.availableFields.length > 1 || 
                (node.attributes && node.attributes.length > 0) || 
                (node.contentSections && node.contentSections.length > 0);
              
              // Add overview option for entities with multiple fields
              if (hasMultipleFields) {
                options.push(`<option value="__overview__" ${initialField === '__overview__' ? 'selected' : ''}>üìã Overview (All Fields)</option>`);
                options.push('<option disabled>‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</option>');
              }
              
              // Add prose fields
              for (const f of node.availableFields) {
                if (!f.startsWith('__')) {
                  options.push(`<option value="${f}" ${f === initialField ? 'selected' : ''}>${f}</option>`);
                }
              }
              
              // Add "new" prose fields if not present
              if (!node.availableFields.includes('body')) {
                options.push(`<option value="body" ${initialField === 'body' ? 'selected' : ''}>body (new)</option>`);
              }
              if (!node.availableFields.includes('summary')) {
                options.push(`<option value="summary" ${initialField === 'summary' ? 'selected' : ''}>summary (new)</option>`);
              }
              
              // Add separator and special fields if present
              const specialFields = node.availableFields.filter(f => f.startsWith('__'));
              if (specialFields.length > 0) {
                options.push('<option disabled>‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</option>');
                for (const f of specialFields) {
                  const isAttributes = f === '__attributes__';
                  const label = isAttributes ? 'üìä attributes' : 'üìù content sections';
                  const count = isAttributes ? node.attributes?.length : node.contentSections?.length;
                  const countStr = count ? ` (${count})` : ' (new)';
                  options.push(`<option value="${f}" ${f === initialField ? 'selected' : ''}>${label}${countStr}</option>`);
                }
              }
              
              return options.join('');
            })()}
          </select>
        </div>
        <div class="node-name-container">
          <span class="node-name editable" id="nodeName" tabindex="0" title="Click to edit title">${this.escapeHtml(node.name)}</span>
          <div class="node-name-edit" id="nodeNameEdit" contenteditable="false" aria-label="Edit title"></div>
        </div>
      </div>
    </div>
    <div class="header-right">
      <span class="word-count" id="wordCount">${wordCount} words</span>
      <button class="save-btn" id="saveBtn" title="Save (Ctrl+S)">
        <svg width="16" height="16" viewBox="0 0 32 32" fill="currentColor" xmlns="http://www.w3.org/2000/svg">
          <path d="M27.71,9.29l-5-5A1,1,0,0,0,22,4H6A2,2,0,0,0,4,6V26a2,2,0,0,0,2,2H26a2,2,0,0,0,2-2V10A1,1,0,0,0,27.71,9.29ZM12,6h8v4H12Zm8,20H12V18h8Zm2,0V18a2,2,0,0,0-2-2H12a2,2,0,0,0-2,2v8H6V6h4v4a2,2,0,0,0,2,2h8a2,2,0,0,0,2-2V6.41l4,4V26Z"/>
        </svg>
      </button>
    </div>
  </div>
  
  <div class="editor-container" id="proseEditor">
    <div class="editor-wrapper">
      <div 
        id="editor" 
        contenteditable="true" 
        spellcheck="true"
        data-placeholder="Start writing..."
      >${escapedProse}</div>
    </div>
  </div>
  
  <!-- Attributes Editor -->
  <div class="structured-editor" id="attributesEditor">
    <div class="structured-header">
      <span class="structured-title">Attributes</span>
      <button class="add-btn" id="addAttrBtn">+ Add Attribute</button>
    </div>
    <div id="attributesContainer">
      ${this.renderAttributesTable(node.attributes || [])}
    </div>
  </div>
  
  <!-- Content Sections Editor -->
  <div class="structured-editor" id="contentEditor">
    <div class="structured-header">
      <span class="structured-title">Content Sections</span>
      <button class="add-btn" id="addContentBtn">+ Add Section</button>
    </div>
    <div id="contentContainer">
      ${this.renderContentSections(node.contentSections || [])}
    </div>
  </div>
  
  <div class="footer">
    <span id="charCount">${prose.length} chars</span>
  </div>
  
  <script nonce="${nonce}">
    const vscode = acquireVsCodeApi();
    const editor = document.getElementById('editor');
    const saveBtn = document.getElementById('saveBtn');
    const wordCountEl = document.getElementById('wordCount');
    const charCountEl = document.getElementById('charCount');
    const fieldSelector = document.getElementById('fieldSelector');
    const nodeNameDisplay = document.getElementById('nodeName');
    const nodeNameEdit = document.getElementById('nodeNameEdit');
    
    let isDirty = false;
    let originalContent = editor.innerText;
    let saveTimeout = null;
    let currentField = '${initialField}';
    let currentEditorMode = '${initialField === '__overview__' ? 'overview' : initialField === '__attributes__' ? 'attributes' : initialField === '__content__' ? 'content' : 'prose'}';
    
    // LOCAL STATE - these are modified instantly, only saved on Save button click
    let localAttributes = ${JSON.stringify(node.attributes || [])};
    let localContentSections = ${JSON.stringify(node.contentSections || [])};
    let attributesDirty = false;
    let contentSectionsDirty = false;
    
    // Detect system theme for JavaScript access
    function detectSystemTheme() {
      return window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light';
    }
    
    // Update data attribute for system theme (enhances CSS)
    function updateSystemThemeAttribute() {
      const systemTheme = detectSystemTheme();
      document.documentElement.setAttribute('data-detected-system', systemTheme);
    }
    
    // Initialize system theme detection
    updateSystemThemeAttribute();
    
    // Listen for system theme changes
    window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', () => {
      updateSystemThemeAttribute();
    });
    
    // Update word count
    function updateCounts() {
      const text = editor.innerText;
      const words = text.trim() ? text.trim().split(/\\s+/).length : 0;
      const chars = text.length;
      wordCountEl.textContent = words + ' words';
      charCountEl.textContent = chars + ' chars';
    }
    
    // Mark prose as dirty
    function markDirty() {
      isDirty = true;
      updateDirtyIndicator();
    }
    
    function markAttributesDirty() {
      attributesDirty = true;
      updateDirtyIndicator();
    }
    
    function markContentSectionsDirty() {
      contentSectionsDirty = true;
      updateDirtyIndicator();
    }
    
    // ----- Inline title editing -----
    let isEditingName = false;
    let isSubmittingName = false;
    
    function enterNameEdit() {
      if (!nodeNameDisplay || !nodeNameEdit || isSubmittingName) return;
      if (isEditingName) return;
      isEditingName = true;
      nodeNameEdit.textContent = nodeNameDisplay.textContent.trim();
      nodeNameDisplay.classList.add('editing-hidden');
      nodeNameEdit.classList.add('editing-active');
      nodeNameEdit.contentEditable = 'true';
      nodeNameEdit.focus();
      // Select all text
      const range = document.createRange();
      range.selectNodeContents(nodeNameEdit);
      const sel = window.getSelection();
      sel.removeAllRanges();
      sel.addRange(range);
    }
    
    function exitNameEdit() {
      if (!nodeNameDisplay || !nodeNameEdit) return;
      isEditingName = false;
      nodeNameEdit.contentEditable = 'false';
      nodeNameEdit.classList.remove('editing-active');
      nodeNameDisplay.classList.remove('editing-hidden');
    }
    
    function submitNameEdit() {
      if (!nodeNameDisplay || !nodeNameEdit) return;
      if (isSubmittingName) return;
      
      const newName = nodeNameEdit.textContent.trim();
      const currentName = nodeNameDisplay.textContent.trim();
      
      exitNameEdit();
      
      if (!newName || newName === currentName) {
        nodeNameEdit.textContent = currentName;
        return;
      }
      
      isSubmittingName = true;
      vscode.postMessage({
        type: 'renameName',
        name: newName
      });
      
      // Slight delay to avoid double submits from blur + enter
      setTimeout(() => {
        isSubmittingName = false;
      }, 0);
    }
    
    if (nodeNameDisplay && nodeNameEdit) {
      nodeNameDisplay.addEventListener('click', enterNameEdit);
      nodeNameDisplay.addEventListener('keydown', (e) => {
        if (e.key === 'Enter' || e.key === ' ') {
          e.preventDefault();
          enterNameEdit();
        }
      });
      
      nodeNameEdit.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
          e.preventDefault();
          submitNameEdit();
        } else if (e.key === 'Escape') {
          e.preventDefault();
          nodeNameEdit.textContent = nodeNameDisplay.textContent.trim();
          exitNameEdit();
        }
      });
      
      nodeNameEdit.addEventListener('blur', () => {
        if (isEditingName) {
          submitNameEdit();
        }
      });
    }
    // ----- End inline title editing -----
    
    function updateDirtyIndicator() {
      const anyDirty = isDirty || attributesDirty || contentSectionsDirty;
      if (anyDirty) {
        saveBtn.classList.add('dirty');
        saveBtn.classList.remove('saved-flash');
        saveBtn.title = 'Unsaved changes - Click to save or Ctrl+S';
      } else {
        saveBtn.classList.remove('dirty');
        saveBtn.title = 'All changes saved';
      }
    }
    
    // Mark as clean
    function markClean() {
      isDirty = false;
      attributesDirty = false;
      contentSectionsDirty = false;
      updateDirtyIndicator();
      originalContent = editor.innerText;
    }
    
    // Save function - saves ALL pending changes
    function save() {
      const anyDirty = isDirty || attributesDirty || contentSectionsDirty;
      if (!anyDirty) return;
      
      saveBtn.disabled = true;
      saveBtn.classList.remove('dirty');
      saveBtn.title = 'Saving...';
      
      // Save prose if dirty
      if (isDirty) {
        vscode.postMessage({
          type: 'save',
          text: editor.innerText,
          field: currentField
        });
      }
      
      // Save attributes if dirty
      if (attributesDirty) {
        vscode.postMessage({
          type: 'saveAttributes',
          attributes: localAttributes
        });
      }
      
      // Save content sections if dirty
      if (contentSectionsDirty) {
        vscode.postMessage({
          type: 'saveContentSections',
          sections: localContentSections
        });
      }
    }
    
    // Editor containers
    const proseEditor = document.getElementById('proseEditor');
    const attributesEditor = document.getElementById('attributesEditor');
    const contentEditor = document.getElementById('contentEditor');
    
    // Show/hide editors based on field type
    function showEditor(editorType) {
      // Remove all mode classes
      document.body.classList.remove('mode-prose', 'mode-structured', 'mode-overview');
      
      // Add appropriate mode class
      if (editorType === 'overview') {
        document.body.classList.add('mode-overview');
      } else if (editorType === 'attributes' || editorType === 'content') {
        document.body.classList.add('mode-structured');
        // Keep active class for structured editor selection
        attributesEditor.classList.toggle('active', editorType === 'attributes');
        contentEditor.classList.toggle('active', editorType === 'content');
      } else {
        // prose mode
        document.body.classList.add('mode-prose');
      }
    }
    
    // Handle field change
    fieldSelector.addEventListener('change', (e) => {
      // Save current content first if dirty
      if (isDirty) {
        save();
      }
      
      const newField = e.target.value;
      currentField = newField;
      
      // Determine which editor to show
      if (newField === '__overview__') {
        showEditor('overview');
        currentEditorMode = 'overview';
        // Overview mode shows all existing editors - no rendering needed
        // Just ensure attributes and content are rendered
        renderAttributesTable();
        renderContentSections();
      } else if (newField === '__attributes__') {
        showEditor('attributes');
        currentEditorMode = 'attributes';
        // Render from local state (no network call needed)
        renderAttributesTable();
      } else if (newField === '__content__') {
        showEditor('content');
        currentEditorMode = 'content';
        // Render from local state (no network call needed)
        renderContentSections();
      } else {
        showEditor('prose');
        currentEditorMode = 'prose';
        // Request content for the new field (prose still needs fetch)
        vscode.postMessage({
          type: 'switchField',
          field: newField
        });
      }
    });
    
    // Attributes Editor Handlers - LOCAL STATE ONLY (fast!)
    const addAttrBtn = document.getElementById('addAttrBtn');
    const attributesContainer = document.getElementById('attributesContainer');
    
    // Re-render attributes from local state (card-based layout)
    function renderAttributesTable() {
      if (localAttributes.length === 0) {
        attributesContainer.innerHTML = \`
          <div class="empty-state">
            <div class="empty-state-icon">üìä</div>
            <p>No attributes yet</p>
            <p style="font-size: 0.8rem;">Click "+ Add Attribute" to create one</p>
          </div>
        \`;
        return;
      }
      
      attributesContainer.innerHTML = localAttributes.map((attr, i) => \`
        <div class="attr-card" data-index="\${i}">
          <div class="attr-card-content">
            <div class="attr-title">
              <span class="attr-name name-field inline-editable" data-index="\${i}" tabindex="0" title="Click to edit name">\${escapeHtml(attr.name || 'Untitled')}</span>
              <span class="attr-name-edit name-field inline-edit-field" data-index="\${i}" contenteditable="false"></span>
              <span class="key-badge" data-index="\${i}">\${escapeHtml(attr.key || '')}</span>
            </div>
            <input type="text" class="attr-value-input" data-index="\${i}" value="\${escapeHtml(String(attr.value || ''))}" placeholder="Value" />
            <select class="type-select" data-index="\${i}">
              <option value="" \${!attr.dataType && !attr.type ? 'selected' : ''}>auto</option>
              <option value="string" \${attr.dataType === 'string' || attr.type === 'string' ? 'selected' : ''}>string</option>
              <option value="int" \${attr.dataType === 'int' || attr.type === 'int' ? 'selected' : ''}>int</option>
              <option value="float" \${attr.dataType === 'float' || attr.type === 'float' ? 'selected' : ''}>float</option>
              <option value="bool" \${attr.dataType === 'bool' || attr.type === 'bool' ? 'selected' : ''}>bool</option>
            </select>
            <div class="dropdown-menu">
              <button class="menu-btn" title="More options">‚ãÆ</button>
              <div class="menu-dropdown">
                <button class="menu-item delete-item" data-index="\${i}">üóë Delete</button>
              </div>
            </div>
          </div>
        </div>
      \`).join('');
    }
    
    function escapeHtml(str) {
      return str.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
    }
    
    // Track editing state for attributes
    const attrEditingState = new Map(); // index -> { isEditing: bool, isSubmitting: bool }
    
    function enterAttrEdit(index) {
      const key = \`attr-\${index}\`;
      if (attrEditingState.get(key)?.isEditing || attrEditingState.get(key)?.isSubmitting) return;
      
      const displaySpan = attributesContainer.querySelector(\`.attr-name[data-index="\${index}"]\`);
      const editSpan = attributesContainer.querySelector(\`.attr-name-edit[data-index="\${index}"]\`);
      
      if (!displaySpan || !editSpan) return;
      
      attrEditingState.set(key, { isEditing: true, isSubmitting: false });
      editSpan.textContent = displaySpan.textContent.trim();
      displaySpan.classList.add('editing-hidden');
      editSpan.classList.add('editing-active');
      editSpan.contentEditable = 'true';
      editSpan.focus();
      
      // Select all text
      const range = document.createRange();
      range.selectNodeContents(editSpan);
      const sel = window.getSelection();
      sel.removeAllRanges();
      sel.addRange(range);
    }
    
    function exitAttrEdit(index) {
      const key = \`attr-\${index}\`;
      const displaySpan = attributesContainer.querySelector(\`.attr-name[data-index="\${index}"]\`);
      const editSpan = attributesContainer.querySelector(\`.attr-name-edit[data-index="\${index}"]\`);
      
      if (!displaySpan || !editSpan) return;
      
      const state = attrEditingState.get(key);
      if (state) state.isEditing = false;
      
      editSpan.contentEditable = 'false';
      editSpan.classList.remove('editing-active');
      displaySpan.classList.remove('editing-hidden');
    }
    
    function submitAttrEdit(index) {
      const key = \`attr-\${index}\`;
      const state = attrEditingState.get(key);
      if (state?.isSubmitting) return;
      
      const displaySpan = attributesContainer.querySelector(\`.attr-name[data-index="\${index}"]\`);
      const editSpan = attributesContainer.querySelector(\`.attr-name-edit[data-index="\${index}"]\`);
      
      if (!displaySpan || !editSpan) return;
      
      const newValue = editSpan.textContent.trim();
      const currentValue = displaySpan.textContent.trim();
      
      exitAttrEdit(index);
      
      if (!newValue || newValue === currentValue) {
        editSpan.textContent = currentValue;
        return;
      }
      
      if (state) state.isSubmitting = true;
      
      // Update local state
      localAttributes[index].name = newValue;
      
      // Auto-generate key from name
      const sanitizedKey = sanitizeKey(newValue);
      localAttributes[index].key = sanitizedKey;
      
      // Update key display
      const keySpan = attributesContainer.querySelector(\`.attr-key[data-index="\${index}"]\`);
      if (keySpan) {
        keySpan.textContent = sanitizedKey;
      }
      
      markAttributesDirty();
      
      // Update display
      displaySpan.textContent = newValue;
      
      if (state) state.isSubmitting = false;
    }
    
    addAttrBtn.addEventListener('click', () => {
      // Add to local state instantly
      localAttributes.push({ key: '', name: 'Untitled', value: '', dataType: undefined });
      markAttributesDirty();
      renderAttributesTable();
    });
    
    attributesContainer.addEventListener('input', (e) => {
      const target = e.target;
      if (target.classList.contains('attr-value-input')) {
        const card = target.closest('.attr-card');
        const index = parseInt(card.dataset.index);
        // Update local state instantly (no network call!)
        if (localAttributes[index]) {
          localAttributes[index].value = target.value;
          markAttributesDirty();
        }
      } else if (target.classList.contains('type-select')) {
        const card = target.closest('.attr-card');
        const index = parseInt(card.dataset.index);
        // Update local state instantly
        if (localAttributes[index]) {
          localAttributes[index].dataType = target.value || undefined;
          markAttributesDirty();
        }
      }
    });
    
    attributesContainer.addEventListener('click', (e) => {
      // Handle inline editing clicks
      const nameSpan = e.target.closest('.attr-name.editable');
      if (nameSpan) {
        e.stopPropagation();
        e.preventDefault();
        const index = parseInt(nameSpan.dataset.index);
        enterAttrEdit(index);
        return;
      }
      
      // Handle menu button click
      const menuBtn = e.target.closest('.menu-btn');
      if (menuBtn) {
        e.stopPropagation();
        e.preventDefault();
        const menu = menuBtn.closest('.dropdown-menu');
        // Close all other menus
        attributesContainer.querySelectorAll('.dropdown-menu.active').forEach(m => {
          if (m !== menu) m.classList.remove('active');
        });
        // Toggle this menu
        menu.classList.toggle('active');
        return;
      }
      
      // Handle delete menu item click
      const deleteItem = e.target.closest('.delete-item');
      if (deleteItem) {
        e.stopPropagation();
        e.preventDefault();
        const index = parseInt(deleteItem.dataset.index);
        // Remove from local state instantly (no confirm - it doesn't work in webviews)
        localAttributes.splice(index, 1);
        markAttributesDirty();
        renderAttributesTable();
        return;
      }
      
      // Close any open menus when clicking elsewhere
      attributesContainer.querySelectorAll('.dropdown-menu.active').forEach(m => {
        m.classList.remove('active');
      });
    });
    
    attributesContainer.addEventListener('keydown', (e) => {
      const editSpan = e.target.closest('.attr-name-edit');
      if (!editSpan) return;
      
      const index = parseInt(editSpan.dataset.index);
      
      if (e.key === 'Enter') {
        e.preventDefault();
        submitAttrEdit(index);
      } else if (e.key === 'Escape') {
        e.preventDefault();
        const displaySpan = attributesContainer.querySelector(\`.attr-name[data-index="\${index}"]\`);
        editSpan.textContent = displaySpan.textContent.trim();
        exitAttrEdit(index);
      }
    });
    
    attributesContainer.addEventListener('blur', (e) => {
      const editSpan = e.target.closest('.attr-name-edit');
      if (!editSpan) return;
      
      const index = parseInt(editSpan.dataset.index);
      const key = \`attr-\${index}\`;
      if (attrEditingState.get(key)?.isEditing) {
        submitAttrEdit(index);
      }
    }, true);
    
    // Content Sections Editor Handlers - LOCAL STATE ONLY (fast!)
    const addContentBtn = document.getElementById('addContentBtn');
    const contentContainer = document.getElementById('contentContainer');
    
    // Re-render content sections from local state
    function renderContentSections() {
      if (localContentSections.length === 0) {
        contentContainer.innerHTML = \`
          <div class="empty-state">
            <div class="empty-state-icon">üìù</div>
            <p>No content sections yet</p>
            <p style="font-size: 0.8rem;">Click "+ Add Section" to create one</p>
          </div>
        \`;
        return;
      }
      
      contentContainer.innerHTML = localContentSections.map((section, i) => \`
        <div class="content-section" data-index="\${i}">
          <div class="content-section-header">
            <div class="content-section-title">
              <span class="content-section-toggle">‚ñ∂</span>
              <span class="content-section-name name-field inline-editable" data-index="\${i}" tabindex="0" title="Click to edit name">\${escapeHtml(section.name || 'Untitled')}</span>
              <span class="content-section-name-edit name-field inline-edit-field" data-index="\${i}" contenteditable="false"></span>
              <span class="content-section-key key-badge inline-editable" data-index="\${i}" tabindex="0" title="Click to edit key">\${escapeHtml(section.key || '')}</span>
              <span class="content-section-key-edit inline-edit-field" data-index="\${i}" contenteditable="false"></span>
            </div>
            <div class="dropdown-menu">
              <button class="menu-btn" title="More options">‚ãÆ</button>
              <div class="menu-dropdown">
                <button class="menu-item delete-item" data-index="\${i}">üóë Delete</button>
              </div>
            </div>
          </div>
          <div class="content-section-body">
            <textarea class="content-textarea" data-index="\${i}">\${escapeHtml(section.value || '')}</textarea>
          </div>
        </div>
      \`).join('');
    }
    
    addContentBtn.addEventListener('click', () => {
      // Add to local state instantly
      localContentSections.push({ key: '', name: '', value: '' });
      markContentSectionsDirty();
      renderContentSections();
      // Expand the new section
      const newSection = contentContainer.querySelector('.content-section:last-child');
      if (newSection) newSection.classList.add('expanded');
    });
    
    // Track editing state for content sections
    const editingState = new Map(); // sectionIndex -> { field: 'name'|'key', isEditing: bool, isSubmitting: bool }
    
    function enterContentSectionEdit(index, field) {
      const key = \`\${index}-\${field}\`;
      if (editingState.get(key)?.isEditing || editingState.get(key)?.isSubmitting) return;
      
      const displaySpan = contentContainer.querySelector(\`.content-section-\${field}[data-index="\${index}"]\`);
      const editSpan = contentContainer.querySelector(\`.content-section-\${field}-edit[data-index="\${index}"]\`);
      
      if (!displaySpan || !editSpan) return;
      
      editingState.set(key, { field, isEditing: true, isSubmitting: false });
      editSpan.textContent = displaySpan.textContent.trim();
      displaySpan.classList.add('editing-hidden');
      editSpan.classList.add('editing-active');
      editSpan.contentEditable = 'true';
      editSpan.focus();
      
      // Select all text
      const range = document.createRange();
      range.selectNodeContents(editSpan);
      const sel = window.getSelection();
      sel.removeAllRanges();
      sel.addRange(range);
    }
    
    function exitContentSectionEdit(index, field) {
      const key = \`\${index}-\${field}\`;
      const displaySpan = contentContainer.querySelector(\`.content-section-\${field}[data-index="\${index}"]\`);
      const editSpan = contentContainer.querySelector(\`.content-section-\${field}-edit[data-index="\${index}"]\`);
      
      if (!displaySpan || !editSpan) return;
      
      const state = editingState.get(key);
      if (state) state.isEditing = false;
      
      editSpan.contentEditable = 'false';
      editSpan.classList.remove('editing-active');
      displaySpan.classList.remove('editing-hidden');
    }
    
    function sanitizeKey(name) {
      return name
        .toLowerCase()
        .replace(/[^a-z0-9]+/g, '_')  // Replace non-alphanumeric with underscore
        .replace(/^_+|_+$/g, '')       // Remove leading/trailing underscores
        .replace(/_+/g, '_');          // Replace multiple underscores with single
    }
    
    function submitContentSectionEdit(index, field) {
      const key = \`\${index}-\${field}\`;
      const state = editingState.get(key);
      if (state?.isSubmitting) return;
      
      const displaySpan = contentContainer.querySelector(\`.content-section-\${field}[data-index="\${index}"]\`);
      const editSpan = contentContainer.querySelector(\`.content-section-\${field}-edit[data-index="\${index}"]\`);
      
      if (!displaySpan || !editSpan) return;
      
      const newValue = editSpan.textContent.trim();
      const currentValue = displaySpan.textContent.trim();
      
      exitContentSectionEdit(index, field);
      
      if (!newValue || newValue === currentValue) {
        editSpan.textContent = currentValue;
        return;
      }
      
      if (state) state.isSubmitting = true;
      
      // Update local state
      localContentSections[index][field] = newValue;
      
      // Auto-generate key from name
      if (field === 'name') {
        const sanitizedKey = sanitizeKey(newValue);
        localContentSections[index].key = sanitizedKey;
        
        // Update key display
        const keyDisplaySpan = contentContainer.querySelector(\`.content-section-key[data-index="\${index}"]\`);
        if (keyDisplaySpan) {
          keyDisplaySpan.textContent = sanitizedKey;
        }
      }
      
      markContentSectionsDirty();
      
      // Update display
      displaySpan.textContent = newValue;
      
      if (state) state.isSubmitting = false;
    }
    
    contentContainer.addEventListener('click', (e) => {
      // Don't toggle if clicking on any editable elements or their edit spans
      const nameSpan = e.target.closest('.content-section-name.editable, .content-section-name-edit');
      const keySpan = e.target.closest('.content-section-key.editable, .content-section-key-edit');
      
      // Handle inline editing clicks
      if (nameSpan && nameSpan.classList.contains('editable')) {
        e.stopPropagation();
        e.preventDefault();
        const index = parseInt(nameSpan.dataset.index);
        enterContentSectionEdit(index, 'name');
        return;
      } else if (keySpan && keySpan.classList.contains('editable')) {
        e.stopPropagation();
        e.preventDefault();
        const index = parseInt(keySpan.dataset.index);
        enterContentSectionEdit(index, 'key');
        return;
      } else if (nameSpan || keySpan) {
        // Clicked on edit span while editing - don't toggle
        e.stopPropagation();
        return;
      }
      
      // Handle menu button click
      const menuBtn = e.target.closest('.menu-btn');
      if (menuBtn) {
        e.stopPropagation();
        e.preventDefault();
        const menu = menuBtn.closest('.dropdown-menu');
        // Close all other menus
        contentContainer.querySelectorAll('.dropdown-menu.active').forEach(m => {
          if (m !== menu) m.classList.remove('active');
        });
        // Toggle this menu
        menu.classList.toggle('active');
        return;
      }
      
      // Handle delete menu item click
      const deleteItem = e.target.closest('.delete-item');
      if (deleteItem) {
        e.stopPropagation();
        e.preventDefault();
        const index = parseInt(deleteItem.dataset.index);
        // Remove from local state instantly (no confirm - it doesn't work in webviews)
        localContentSections.splice(index, 1);
        markContentSectionsDirty();
        renderContentSections();
        return;
      }
      
      // Close any open menus when clicking elsewhere
      contentContainer.querySelectorAll('.dropdown-menu.active').forEach(m => {
        m.classList.remove('active');
      });
      
      // Only toggle if clicking directly on the header (not on interactive elements)
      const header = e.target.closest('.content-section-header');
      if (header) {
        const section = header.closest('.content-section');
        section.classList.toggle('expanded');
      }
    });
    
    contentContainer.addEventListener('input', (e) => {
      if (e.target.classList.contains('content-textarea')) {
        const index = parseInt(e.target.dataset.index);
        localContentSections[index].value = e.target.value;
        markContentSectionsDirty();
      }
    });
    
    contentContainer.addEventListener('keydown', (e) => {
      const editSpan = e.target.closest('.content-section-name-edit, .content-section-key-edit');
      if (!editSpan) return;
      
      const index = parseInt(editSpan.dataset.index);
      const field = editSpan.classList.contains('content-section-name-edit') ? 'name' : 'key';
      
      if (e.key === 'Enter') {
        e.preventDefault();
        submitContentSectionEdit(index, field);
      } else if (e.key === 'Escape') {
        e.preventDefault();
        const displaySpan = contentContainer.querySelector(\`.content-section-\${field}[data-index="\${index}"]\`);
        editSpan.textContent = displaySpan.textContent.trim();
        exitContentSectionEdit(index, field);
      }
    });
    
    contentContainer.addEventListener('blur', (e) => {
      const editSpan = e.target.closest('.content-section-name-edit, .content-section-key-edit');
      if (!editSpan) return;
      
      const index = parseInt(editSpan.dataset.index);
      const field = editSpan.classList.contains('content-section-name-edit') ? 'name' : 'key';
      
      const key = \`\${index}-\${field}\`;
      if (editingState.get(key)?.isEditing) {
        submitContentSectionEdit(index, field);
      }
    }, true);
    
    // Close menus when clicking outside
    document.addEventListener('click', (e) => {
      if (!e.target.closest('.dropdown-menu')) {
        contentContainer.querySelectorAll('.dropdown-menu.active').forEach(m => {
          m.classList.remove('active');
        });
        attributesContainer.querySelectorAll('.dropdown-menu.active').forEach(m => {
          m.classList.remove('active');
        });
      }
    });
    
    // Throttle content change messages to avoid flooding
    let contentChangeTimeout = null;
    
    // Handle content changes
    function handleEditorChange() {
      markDirty();
      updateCounts();
      
      // Send content update to extension (throttled)
      if (contentChangeTimeout) {
        clearTimeout(contentChangeTimeout);
      }
      contentChangeTimeout = setTimeout(() => {
        vscode.postMessage({
          type: 'contentChanged',
          text: editor.innerText,
          field: currentField
        });
      }, 500); // Send every 500ms max
      
      // Auto-save after 2 seconds of inactivity
      if (saveTimeout) {
        clearTimeout(saveTimeout);
      }
      saveTimeout = setTimeout(() => {
        if (isDirty) {
          save();
        }
      }, 2000);
    }
    
    editor.addEventListener('input', handleEditorChange);
    editor.addEventListener('beforeinput', handleEditorChange);
    
    // Handle keyboard shortcuts
    editor.addEventListener('keydown', (e) => {
      // Ctrl/Cmd + S to save
      if ((e.ctrlKey || e.metaKey) && e.key === 's') {
        e.preventDefault();
        save();
      }
    });
    
    // Save button click
    saveBtn.addEventListener('click', save);
    
    // Handle blur (save on focus loss)
    editor.addEventListener('blur', () => {
      if (isDirty) {
        save();
      }
    });
    
    // Handle messages from extension
    window.addEventListener('message', (event) => {
      const message = event.data;
      switch (message.type) {
        case 'saved':
          // Only mark prose as clean; attributes/content have their own tracking
          isDirty = false;
          checkAllClean();
          break;
        case 'nameUpdated':
          if (nodeNameDisplay && nodeNameEdit) {
            nodeNameDisplay.textContent = message.name;
            nodeNameEdit.textContent = message.name;
            exitNameEdit();
          }
          break;
        case 'nameUpdateError':
          if (message.error) {
            alert(message.error);
          }
          break;
        case 'saveComplete':
          // All saves complete - mark everything clean
          markClean();
          saveBtn.disabled = false;
          saveBtn.classList.remove('dirty');
          saveBtn.classList.add('saved-flash');
          saveBtn.title = 'All changes saved';
          setTimeout(() => {
            saveBtn.classList.remove('saved-flash');
          }, 1000);
          break;
        case 'content':
          if (!isDirty) {
            editor.innerText = message.text;
            updateCounts();
          }
          break;
        case 'fieldContent':
          // Switched to a new field
          editor.innerText = message.text || '';
          currentField = message.field;
          originalContent = editor.innerText;
          isDirty = false;
          updateDirtyIndicator();
          updateCounts();
          editor.focus();
          break;
          
        case 'switchToField':
          // External request to switch to a specific field
          fieldSelector.value = message.field;
          fieldSelector.dispatchEvent(new Event('change'));
          break;
          
        case 'themeChanged':
          // Update theme setting
          document.documentElement.setAttribute('data-theme-setting', message.themeSetting);
          document.documentElement.setAttribute('data-vscode-theme', message.vscodeTheme);
          updateSystemThemeAttribute();
          break;
      }
    });
    
    // Check if all saves are complete
    function checkAllClean() {
      if (!isDirty && !attributesDirty && !contentSectionsDirty) {
        saveBtn.disabled = false;
        saveBtn.classList.remove('dirty');
        saveBtn.classList.add('saved-flash');
        saveBtn.title = 'All changes saved';
        setTimeout(() => {
          saveBtn.classList.remove('saved-flash');
        }, 1000);
      }
    }
    
    // Initial counts
    updateCounts();
    
    // Initialize with remembered field/editor mode
    if (currentEditorMode === 'overview') {
      showEditor('overview');
      renderAttributesTable();
      renderContentSections();
    } else if (currentEditorMode === 'attributes') {
      showEditor('attributes');
      renderAttributesTable();
    } else if (currentEditorMode === 'content') {
      showEditor('content');
      renderContentSections();
    } else {
      showEditor('prose');
      editor.focus();
    }
  </script>
</body>
</html>`;
  }
  
  /**
   * Generate a nonce for CSP
   */
  private getNonce(): string {
    let text = '';
    const possible = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
    for (let i = 0; i < 32; i++) {
      text += possible.charAt(Math.floor(Math.random() * possible.length));
    }
    return text;
  }
  
  /**
   * Render the attributes table HTML
   */
  private renderAttributesTable(attributes: CodexAttribute[]): string {
    if (attributes.length === 0) {
      return `
        <div class="empty-state">
          <div class="empty-state-icon">üìä</div>
          <p>No attributes yet</p>
          <p style="font-size: 0.8rem;">Click "+ Add Attribute" to create one</p>
        </div>
      `;
    }
    
    return attributes.map((attr, idx) => `
      <div class="attr-card" data-index="${idx}">
        <div class="attr-card-content">
          <div class="attr-title">
            <span class="attr-name name-field inline-editable" data-index="${idx}" tabindex="0" title="Click to edit name">${this.escapeHtml(attr.name || 'Untitled')}</span>
            <span class="attr-name-edit name-field inline-edit-field" data-index="${idx}" contenteditable="false"></span>
            <span class="key-badge" data-index="${idx}">${this.escapeHtml(attr.key || '')}</span>
          </div>
          <input type="text" class="attr-value-input" data-index="${idx}" value="${this.escapeHtml(String(attr.value ?? ''))}" placeholder="Value" />
          <select class="type-select" data-index="${idx}">
            <option value="" ${!attr.dataType ? 'selected' : ''}>auto</option>
            <option value="string" ${attr.dataType === 'string' ? 'selected' : ''}>string</option>
            <option value="int" ${attr.dataType === 'int' ? 'selected' : ''}>int</option>
            <option value="float" ${attr.dataType === 'float' ? 'selected' : ''}>float</option>
            <option value="bool" ${attr.dataType === 'bool' ? 'selected' : ''}>bool</option>
            <option value="date" ${attr.dataType === 'date' ? 'selected' : ''}>date</option>
          </select>
          <div class="dropdown-menu">
            <button class="menu-btn" title="More options">‚ãÆ</button>
            <div class="menu-dropdown">
              <button class="menu-item delete-item" data-index="${idx}">üóë Delete</button>
            </div>
          </div>
        </div>
      </div>
    `).join('');
  }
  
  /**
   * Render the content sections HTML
   */
  private renderContentSections(sections: CodexContentSection[]): string {
    if (sections.length === 0) {
      return `
        <div class="empty-state">
          <div class="empty-state-icon">üìù</div>
          <p>No content sections yet</p>
          <p style="font-size: 0.8rem;">Click "+ Add Section" to create one</p>
        </div>
      `;
    }
    
    return sections.map((section, idx) => `
      <div class="content-section" data-index="${idx}">
        <div class="content-section-header">
          <div class="content-section-title">
            <span class="content-section-toggle">‚ñ∂</span>
            <span class="content-section-name">${this.escapeHtml(section.name || 'Untitled')}</span>
            <span class="content-section-key">${this.escapeHtml(section.key || '')}</span>
          </div>
          <button class="delete-btn" title="Delete section">üóë</button>
        </div>
        <div class="content-section-body">
          <div class="content-section-meta">
            <div style="flex: 1;">
              <label>Key</label>
              <input type="text" value="${this.escapeHtml(section.key || '')}" 
                     data-field="key" class="section-input">
            </div>
            <div style="flex: 2;">
              <label>Name</label>
              <input type="text" value="${this.escapeHtml(section.name || '')}" 
                     data-field="name" class="section-input">
            </div>
          </div>
          <textarea class="content-textarea" data-field="value" 
                    placeholder="Enter content...">${this.escapeHtml(section.value || '')}</textarea>
        </div>
      </div>
    `).join('');
  }
  
  /**
   * Escape HTML entities
   */
  private escapeHtml(str: string): string {
    return str
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;')
      .replace(/"/g, '&quot;')
      .replace(/'/g, '&#039;');
  }
  
  /**
   * Dispose all panels
   */
  dispose(): void {
    for (const panel of this.panels.values()) {
      panel.dispose();
    }
    this.panels.clear();
    this.panelStats.clear();
    this.hideStatusBar();
  }
}







